/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./plugins/layout.forceAtlas2/layout.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./plugins/layout.forceAtlas2/body.js":
/*!********************************************!*\
  !*** ./plugins/layout.forceAtlas2/body.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileOverview body
 * @author shiwu.wyy@antfin.com
 */
// represents a body(a point mass) and its position
var Body =
/*#__PURE__*/
function () {
  function Body(params) {
    /**
     * the id of this body, the same with the node id
     * @type  {number}
     */
    this.id = params.id;
    /**
     * the position of this body
     * @type  {number}
     */

    this.rx = params.rx;
    /**
     * the position of this body
     * @type  {number}
     */

    this.ry = params.ry;
    /**
     * the force acting on this body
     * @type  {number}
     */

    this.fx = 0;
    /**
     * the force acting on this body
     * @type  {number}
     */

    this.fy = 0;
    /**
     * the mass of this body, =1 for a node
     * @type  {number}
     */

    this.mass = params.mass;
    /**
     * the degree of the node represented by this body
     * @type  {number}
     */

    this.degree = params.degree;
    /**
     * the parameter for repulsive force, = kr
     * @type  {number}
     */

    this.G = params.G;
  } // returns the euclidean distance


  var _proto = Body.prototype;

  _proto.distanceTo = function distanceTo(bo) {
    var dx = this.rx - bo.rx;
    var dy = this.ry - bo.ry;
    return Math.hypot(dx, dy);
  };

  _proto.setPos = function setPos(x, y) {
    this.rx = x;
    this.ry = y;
  }; // resets the forces


  _proto.resetForce = function resetForce() {
    this.fx = 0;
    this.fy = 0;
  };

  _proto.addForce = function addForce(b) {
    var dx = b.rx - this.rx;
    var dy = b.ry - this.ry;
    var dist = Math.hypot(dx, dy);
    dist = dist < 0.0001 ? 0.0001 : dist; // the repulsive defined by force atlas 2

    var F = this.G * (this.degree + 1) * (b.degree + 1) / dist;
    this.fx += F * dx / dist;
    this.fy += F * dy / dist;
  }; // if quad contains this body


  _proto.in = function _in(quad) {
    return quad.contains(this.rx, this.ry);
  }; // returns a new body


  _proto.add = function add(bo) {
    var nenwMass = this.mass + bo.mass;
    var x = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;
    var y = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;
    var dg = this.degree + bo.degree;
    var params = {
      rx: x,
      ry: y,
      mass: nenwMass,
      degree: dg
    };
    return new Body(params);
  };

  return Body;
}();

module.exports = Body;

/***/ }),

/***/ "./plugins/layout.forceAtlas2/forceCalculator.js":
/*!*******************************************************!*\
  !*** ./plugins/layout.forceAtlas2/forceCalculator.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Body = __webpack_require__(/*! ./body */ "./plugins/layout.forceAtlas2/body.js");

var Quad = __webpack_require__(/*! ./quad */ "./plugins/layout.forceAtlas2/quad.js");

var QuadTree = __webpack_require__(/*! ./quadTree */ "./plugins/layout.forceAtlas2/quadTree.js");

var ForceCalculator =
/*#__PURE__*/
function () {
  function ForceCalculator() {}

  var _proto = ForceCalculator.prototype;

  _proto.updateNodesByForces = function updateNodesByForces(data) {
    var nodes = data.nodes,
        edges = data.edges,
        maxIteration = data.maxIteration,
        barnesHut = data.barnesHut,
        prune = data.prune;
    edges = edges.filter(function (edge) {
      return edge.source !== edge.target;
    });
    var size = nodes.length;
    var esize = edges.length;
    var degrees = [];
    var idMap = {};
    var edgeEndsIdMap = {};
    var Es = [];

    for (var i = 0; i < size; i += 1) {
      idMap[nodes[i].id] = i;
      degrees[i] = 0;

      if (nodes[i].x === undefined || isNaN(nodes[i].x)) {
        nodes[i].x = Math.random() * 1000;
      }

      if (nodes[i].y === undefined || isNaN(nodes[i].y)) {
        nodes[i].y = Math.random() * 1000;
      }

      Es.push({
        x: nodes[i].x,
        y: nodes[i].y
      });
    }

    for (var _i = 0; _i < esize; _i += 1) {
      var node1 = void 0;
      var node2 = void 0;
      var sIdx = 0,
          tIdx = 0;

      for (var j = 0; j < size; j += 1) {
        if (nodes[j].id === edges[_i].source) {
          node1 = nodes[j];
          sIdx = j;
        } else if (nodes[j].id === edges[_i].target) {
          node2 = nodes[j];
          tIdx = j;
        }

        edgeEndsIdMap[_i] = {
          sourceIdx: sIdx,
          targetIdx: tIdx
        };
      }

      degrees[idMap[node1.id]] += 1;
      degrees[idMap[node2.id]] += 1;
    }

    var iteration = maxIteration;
    var iterateParam = {
      data: data,
      size: size,
      esize: esize,
      idMap: idMap,
      degrees: degrees,
      iteration: iteration,
      prune: prune,
      barnesHut: barnesHut,
      edgeEndsIdMap: edgeEndsIdMap
    };
    nodes = this.iterate(iterateParam); // if prune, place the leaves around their parents, and then re-layout for several iterations.

    if (prune) {
      for (var _j = 0; _j < esize; _j += 1) {
        if (degrees[edgeEndsIdMap[_j].sourceIdx] <= 1) {
          nodes[edgeEndsIdMap[_j].sourceIdx].x = nodes[edgeEndsIdMap[_j].targetIdx].x;
          nodes[edgeEndsIdMap[_j].sourceIdx].y = nodes[edgeEndsIdMap[_j].targetIdx].y;
        } else if (degrees[edgeEndsIdMap[_j].targetIdx] <= 1) {
          nodes[edgeEndsIdMap[_j].targetIdx].x = nodes[edgeEndsIdMap[_j].sourceIdx].x;
          nodes[edgeEndsIdMap[_j].targetIdx].y = nodes[edgeEndsIdMap[_j].sourceIdx].y;
        }
      }

      prune = false;
      barnesHut = false;
      iteration = 100;
      var iterateParamAfterPrune = {
        data: data,
        size: size,
        esize: esize,
        idMap: idMap,
        degrees: degrees,
        iteration: iteration,
        prune: prune,
        barnesHut: barnesHut,
        edgeEndsIdMap: edgeEndsIdMap
      };
      nodes = this.iterate(iterateParamAfterPrune);
    }

    return nodes;
  };

  _proto.iterate = function iterate(params) {
    var data = params.data,
        size = params.size,
        esize = params.esize,
        idMap = params.idMap,
        degrees = params.degrees,
        iteration = params.iteration,
        prune = params.prune,
        barnesHut = params.barnesHut,
        edgeEndsIdMap = params.edgeEndsIdMap;
    var nodes = data.nodes,
        ks = data.ks,
        kr = data.kr,
        kg = data.kg,
        mode = data.mode,
        prevOverlapping = data.prevOverlapping,
        dissuadeHubs = data.dissuadeHubs,
        ksmax = data.ksmax,
        tao = data.tao,
        center = data.center,
        widths = data.widths;
    var SG = 0;
    var krPrime = 100;
    var iter = iteration;
    var prevoIter = 50;
    var Forces = [];
    var preForces = [];
    var bodies = [];

    for (var i = 0; i < size; i += 1) {
      Forces[2 * i] = 0;
      Forces[2 * i + 1] = 0;

      if (barnesHut) {
        var _params = {
          id: i,
          rx: nodes[i].x,
          ry: nodes[i].y,
          mass: 1,
          G: kr,
          degree: degrees[i]
        };
        bodies[i] = new Body(_params);
        _params = null;
      }
    }

    do {
      for (var _i2 = 0; _i2 < size; _i2 += 1) {
        preForces[2 * _i2] = Forces[2 * _i2];
        preForces[2 * _i2 + 1] = Forces[2 * _i2 + 1];
        Forces[2 * _i2] = 0;
        Forces[2 * _i2 + 1] = 0;
      } // attractive forces, existing on every actual edge


      var attrForceParam = {
        nodes: nodes,
        esize: esize,
        prevOverlapping: prevOverlapping,
        dissuadeHubs: dissuadeHubs,
        mode: mode,
        iter: iter,
        prevoIter: prevoIter,
        Forces: Forces,
        widths: widths,
        idMap: idMap,
        degrees: degrees,
        prune: prune,
        edgeEndsIdMap: edgeEndsIdMap
      };
      Forces = this.getAttrForces(attrForceParam); // repulsive forces and Gravity, existing on every node pair
      // if prevOverlapping, using the no-optimized method in the last prevoIter instead.

      if (barnesHut && (prevOverlapping && iter > prevoIter || !prevOverlapping)) {
        var optRepGraForceParam = {
          nodes: nodes,
          size: size,
          Forces: Forces,
          kg: kg,
          center: center,
          bodies: bodies,
          degrees: degrees,
          prune: prune
        };
        Forces = this.getOptRepGraForces(optRepGraForceParam);
      } else {
        var repGraForceParam = {
          nodes: nodes,
          size: size,
          prevOverlapping: prevOverlapping,
          iter: iter,
          prevoIter: prevoIter,
          Forces: Forces,
          kr: kr,
          krPrime: krPrime,
          kg: kg,
          center: center,
          widths: widths,
          degrees: degrees,
          prune: prune
        };
        Forces = this.getRepGraForces(repGraForceParam);
      } //   // update the positions


      var updatePosParam = {
        size: size,
        nodes: nodes,
        Forces: Forces,
        preForces: preForces,
        SG: SG,
        ks: ks,
        ksmax: ksmax,
        tao: tao,
        degrees: degrees,
        prune: prune
      };
      var res = this.updatePos(updatePosParam);
      nodes = res[0];
      SG = res[1];
      iter -= 1;
    } while (iter > 0);

    return nodes;
  };

  _proto.getAttrForces = function getAttrForces(params) {
    var nodes = params.nodes,
        esize = params.esize,
        prevOverlapping = params.prevOverlapping,
        dissuadeHubs = params.dissuadeHubs,
        mode = params.mode,
        iter = params.iter,
        prevoIter = params.prevoIter,
        Forces = params.Forces,
        widths = params.widths,
        idMap = params.idMap,
        degrees = params.degrees,
        prune = params.prune,
        edgeEndsIdMap = params.edgeEndsIdMap;

    for (var i = 0; i < esize; i += 1) {
      var sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];
      var sourceIdx = edgeEndsIdMap[i].sourceIdx;
      var targetNode = nodes[edgeEndsIdMap[i].targetIdx];
      var targetIdx = edgeEndsIdMap[i].targetIdx;
      if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;
      var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];
      var eucliDis = Math.hypot(dir[0], dir[1]);
      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      if (prevOverlapping && iter < prevoIter) eucliDis = eucliDis - widths[sourceIdx] - widths[targetIdx];
      var Fa1 = eucliDis;
      var Fa2 = Fa1;

      if (mode === 'linlog') {
        Fa1 = Math.log(1 + eucliDis);
        Fa2 = Fa1;
      }

      if (dissuadeHubs) {
        Fa1 = eucliDis / degrees[sourceIdx];
        Fa2 = eucliDis / degrees[targetIdx];
      }

      if (prevOverlapping && iter < prevoIter && eucliDis <= 0) {
        Fa1 = 0;
        Fa2 = 0;
      } else if (prevOverlapping && iter < prevoIter && eucliDis > 0) {
        Fa1 = eucliDis;
        Fa2 = eucliDis;
      }

      Forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];
      Forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];
      Forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];
      Forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];
      dir = null;
    }

    return Forces;
  };

  _proto.getRepGraForces = function getRepGraForces(params) {
    var nodes = params.nodes,
        size = params.size,
        prevOverlapping = params.prevOverlapping,
        iter = params.iter,
        prevoIter = params.prevoIter,
        Forces = params.Forces,
        kr = params.kr,
        krPrime = params.krPrime,
        kg = params.kg,
        center = params.center,
        widths = params.widths,
        degrees = params.degrees,
        prune = params.prune;

    for (var i = 0; i < size; i += 1) {
      for (var j = i + 1; j < size; j += 1) {
        if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;
        var _dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];

        var _eucliDis = Math.hypot(_dir[0], _dir[1]);

        _eucliDis = _eucliDis < 0.0001 ? 0.0001 : _eucliDis;
        _dir[0] = _dir[0] / _eucliDis;
        _dir[1] = _dir[1] / _eucliDis;
        if (prevOverlapping && iter < prevoIter) _eucliDis = _eucliDis - widths[i] - widths[j];
        var Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis;

        if (prevOverlapping && iter < prevoIter && _eucliDis < 0) {
          Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);
        } else if (prevOverlapping && iter < prevoIter && _eucliDis === 0) {
          Fr = 0;
        } else if (prevOverlapping && iter < prevoIter && _eucliDis > 0) {
          Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis;
        }

        Forces[2 * i] -= Fr * _dir[0];
        Forces[2 * j] += Fr * _dir[0];
        Forces[2 * i + 1] -= Fr * _dir[1];
        Forces[2 * j + 1] += Fr * _dir[1];
        _dir = null;
      } // gravity


      var dir = [nodes[i].x - center.x, nodes[i].y - center.y];
      var eucliDis = Math.hypot(dir[0], dir[1]);
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      var Fg = kg * (degrees[i] + 1);
      Forces[2 * i] -= Fg * dir[0];
      Forces[2 * i + 1] -= Fg * dir[1];
      dir = null;
    }

    return Forces;
  };

  _proto.getOptRepGraForces = function getOptRepGraForces(params) {
    var nodes = params.nodes,
        size = params.size,
        Forces = params.Forces,
        kg = params.kg,
        center = params.center,
        bodies = params.bodies,
        degrees = params.degrees,
        prune = params.prune;
    var minx = 9e10,
        maxx = -9e10,
        miny = 9e10,
        maxy = -9e10;

    for (var i = 0; i < size; i += 1) {
      if (prune && degrees[i] <= 1) continue;
      bodies[i].setPos(nodes[i].x, nodes[i].y);
      if (nodes[i].x >= maxx) maxx = nodes[i].x;
      if (nodes[i].x <= minx) minx = nodes[i].x;
      if (nodes[i].y >= maxy) maxy = nodes[i].y;
      if (nodes[i].y <= miny) miny = nodes[i].y;
    }

    var width = Math.max(maxx - minx, maxy - miny);
    var quadParams = {
      xmid: (maxx + minx) / 2,
      ymid: (maxy + miny) / 2,
      length: width,
      massCenter: center,
      mass: size
    };
    var quad = new Quad(quadParams);
    var quadTree = new QuadTree(quad); // build the tree, insert the nodes(quads) into the tree

    for (var _i3 = 0; _i3 < size; _i3 += 1) {
      if (prune && degrees[_i3] <= 1) continue;
      if (bodies[_i3].in(quad)) quadTree.insert(bodies[_i3]);
    } // update the repulsive forces and the gravity.


    for (var _i4 = 0; _i4 < size; _i4 += 1) {
      if (prune && degrees[_i4] <= 1) continue;

      bodies[_i4].resetForce();

      quadTree.updateForce(bodies[_i4]);
      Forces[2 * _i4] -= bodies[_i4].fx;
      Forces[2 * _i4 + 1] -= bodies[_i4].fy; // gravity

      var dir = [nodes[_i4].x - center.x, nodes[_i4].y - center.y];
      var eucliDis = Math.hypot(dir[0], dir[1]);
      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
      dir[0] = dir[0] / eucliDis;
      dir[1] = dir[1] / eucliDis;
      var Fg = kg * (degrees[_i4] + 1);
      Forces[2 * _i4] -= Fg * dir[0];
      Forces[2 * _i4 + 1] -= Fg * dir[1];
      eucliDis = null;
      Fg = null;
      dir = null;
    }

    quadParams = null;
    quad = null;
    quadTree = null;
    width = null;
    return Forces;
  };

  _proto.updatePos = function updatePos(params) {
    var size = params.size,
        nodes = params.nodes,
        Forces = params.Forces,
        preForces = params.preForces,
        SG = params.SG,
        ks = params.ks,
        ksmax = params.ksmax,
        tao = params.tao,
        degrees = params.degrees,
        prune = params.prune;
    var swgns = [];
    var trans = []; // swg(G) and tra(G)

    var swgG = 0;
    var traG = 0;

    for (var i = 0; i < size; i += 1) {
      if (prune && degrees[i] <= 1) continue;
      var minus = [Forces[2 * i] - preForces[2 * i], Forces[2 * i + 1] - preForces[2 * i + 1]];
      var minusNorm = Math.hypot(minus[0], minus[1]);
      var add = [Forces[2 * i] + preForces[2 * i], Forces[2 * i + 1] + preForces[2 * i + 1]];
      var addNorm = Math.hypot(add[0], add[1]);
      swgns[i] = minusNorm;
      trans[i] = addNorm / 2;
      swgG += (degrees[i] + 1) * swgns[i];
      traG += (degrees[i] + 1) * trans[i];
    }

    var preSG = SG;
    SG = tao * traG / swgG;

    if (preSG !== 0) {
      SG = SG > 1.5 * preSG ? 1.5 * preSG : SG;
    } // update the node positions


    for (var _i5 = 0; _i5 < size; _i5 += 1) {
      if (prune && degrees[_i5] <= 1) continue;
      var Sn = ks * SG / (1 + SG * Math.sqrt(swgns[_i5]));
      var absForce = Math.hypot(Forces[2 * _i5], Forces[2 * _i5 + 1]);
      absForce = absForce < 0.0001 ? 0.0001 : absForce;
      var max = ksmax / absForce;
      Sn = Sn > max ? max : Sn;
      var Dnx = Sn * Forces[2 * _i5];
      var Dny = Sn * Forces[2 * _i5 + 1];
      nodes[_i5].x += Dnx;
      nodes[_i5].y += Dny;
    }

    swgns = null;
    trans = null;
    preSG = null;
    return [nodes, SG];
  };

  return ForceCalculator;
}();

module.exports = ForceCalculator;

/***/ }),

/***/ "./plugins/layout.forceAtlas2/layout.worker.js":
/*!*****************************************************!*\
  !*** ./plugins/layout.forceAtlas2/layout.worker.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


const ForceCal = __webpack_require__(/*! ./forceCalculator */ "./plugins/layout.forceAtlas2/forceCalculator.js");
onmessage = function(event) {
  const forceCal = new ForceCal();
  const nodes = forceCal.updateNodesByForces(event.data);
  self.postMessage(nodes);
};


/***/ }),

/***/ "./plugins/layout.forceAtlas2/quad.js":
/*!********************************************!*\
  !*** ./plugins/layout.forceAtlas2/quad.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileOverview quad
 * @author shiwu.wyy@antfin.com
 */
var Quad =
/*#__PURE__*/
function () {
  function Quad(params) {
    /**
     * the center position of this quad
     * @type  {number}
     */
    this.xmid = params.xmid;
    /**
     * the center position of this quad
     * @type  {number}
     */

    this.ymid = params.ymid;
    /**
     * the length of this quad
     * @type  {number}
     */

    this.length = params.length;
    /**
     * the mass center of this quad
     * @type  {number}
     */

    this.massCenter = params.massCenter;
    /**
     * the mass of this quad
     * @type  {number}
     */

    this.mass = params.mass;
  }

  var _proto = Quad.prototype;

  _proto.getLength = function getLength() {
    return this.length;
  };

  _proto.contains = function contains(x, y) {
    var halfLen = this.length / 2;
    return x <= this.xmid + halfLen && x >= this.xmid - halfLen && y <= this.ymid + halfLen && y >= this.ymid - halfLen;
  }; // northwest quadrant


  _proto.NW = function NW() {
    var x = this.xmid - this.length / 4;
    var y = this.ymid + this.length / 4;
    var len = this.length / 2;
    var params = {
      xmid: x,
      ymid: y,
      length: len
    };
    var NW = new Quad(params);
    return NW;
  }; // northeast


  _proto.NE = function NE() {
    var x = this.xmid + this.length / 4;
    var y = this.ymid + this.length / 4;
    var len = this.length / 2;
    var params = {
      xmid: x,
      ymid: y,
      length: len
    };
    var NE = new Quad(params);
    return NE;
  }; // southwest


  _proto.SW = function SW() {
    var x = this.xmid - this.length / 4;
    var y = this.ymid - this.length / 4;
    var len = this.length / 2;
    var params = {
      xmid: x,
      ymid: y,
      length: len
    };
    var SW = new Quad(params);
    return SW;
  }; // southeast


  _proto.SE = function SE() {
    var x = this.xmid + this.length / 4;
    var y = this.ymid - this.length / 4;
    var len = this.length / 2;
    var params = {
      xmid: x,
      ymid: y,
      length: len
    };
    var SE = new Quad(params);
    return SE;
  };

  return Quad;
}();

module.exports = Quad;

/***/ }),

/***/ "./plugins/layout.forceAtlas2/quadTree.js":
/*!************************************************!*\
  !*** ./plugins/layout.forceAtlas2/quadTree.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * @fileOverview quadTree
 * @author shiwu.wyy@antfin.com
 */
var QuadTree =
/*#__PURE__*/
function () {
  // each quadtree represents a quadrant and an aggregate body
  // that represents all bodies inside the quadrant
  function QuadTree(param) {
    /**
     * (aggregated) body in this quad
     * @type  {object}
     */
    this.body = null;
    /**
     * tree representing the northwest quadrant
     * @type  {object}
     */

    this.quad = null;
    this.NW = null;
    this.NE = null;
    this.SW = null;
    this.SE = null;
    /**
     * threshold
     * @type  {number}
     */

    this.theta = 0.5;
    if (param != null) this.quad = param;
  } // insert a body(node) into the tree


  var _proto = QuadTree.prototype;

  _proto.insert = function insert(bo) {
    // if this node does not contain a body, put the new body bo here
    if (this.body == null) {
      this.body = bo;
      return;
    } // internal node


    if (!this._isExternal()) {
      // update mass info
      this.body = this.body.add(bo); // insert body into quadrant

      this._putBody(bo);
    } else {
      // external node
      // divide this region into four children
      this.NW = new QuadTree(this.quad.NW());
      this.NE = new QuadTree(this.quad.NE());
      this.SW = new QuadTree(this.quad.SW());
      this.SE = new QuadTree(this.quad.SE()); // insert this body and bo

      this._putBody(this.body);

      this._putBody(bo); // update the mass info


      this.body = this.body.add(bo);
    }
  }; // inserts bo into a quad


  _proto._putBody = function _putBody(bo) {
    if (bo.in(this.quad.NW())) this.NW.insert(bo);else if (bo.in(this.quad.NE())) this.NE.insert(bo);else if (bo.in(this.quad.SW())) this.SW.insert(bo);else if (bo.in(this.quad.SE())) this.SE.insert(bo);
  };

  _proto._isExternal = function _isExternal() {
    // four children are null
    return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
  }; // update the forces


  _proto.updateForce = function updateForce(bo) {
    if (this.body == null || bo === this.body) {
      return;
    } // if the current node is external


    if (this._isExternal()) bo.addForce(this.body); // internal nodes
    else {
        var s = this.quad.getLength();
        var d = this.body.distanceTo(bo); // b is far enough

        if (s / d < this.theta) bo.addForce(this.body);else {
          this.NW.updateForce(bo);
          this.NE.updateForce(bo);
          this.SW.updateForce(bo);
          this.SE.updateForce(bo);
        }
      }
  };

  return QuadTree;
}();

module.exports = QuadTree;

/***/ })

/******/ });
//# sourceMappingURL=6765ac48c131c1016846.worker.js.map