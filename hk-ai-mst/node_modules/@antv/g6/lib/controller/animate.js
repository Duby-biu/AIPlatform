function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * @fileOverview animate controller
 * @author huangtonger@aliyun.com
 */
var Base = require('./base');

var Util = require('../util/');
/**
 * depth traversal and copy the graphics
 * @param  {object}   map        the index table
 * @param  {array}    parent     parent
 * @param  {number}   count      element count
 * @return {number}   count      element count
 */


function getElements(map, parent, count) {
  var children = parent.get('children');
  Util.each(children, function (child) {
    count++;
    var id = child.gid;

    if (child.isGroup) {
      count = getElements(map, child, count);
    }

    if (!Util.isNil(id)) {
      var stash = {
        matrixStash: Util.cloneDeep(child.getMatrix()),
        element: child,
        visible: child.get('visible')
      };

      if (child.isShape) {
        stash.attrsStash = Util.cloneDeep(child.attr());
      }

      map[id] = stash;
    }
  });
  return count;
}

var Controller =
/*#__PURE__*/
function (_Base) {
  _inheritsLoose(Controller, _Base);

  function Controller(cfg) {
    var _this;

    _this = _Base.call(this, cfg) || this;

    _this._init();

    return _this;
  }

  var _proto = Controller.prototype;

  _proto._init = function _init() {
    var _this2 = this;

    var graph = this.graph;
    graph.on('afteritemdraw', function (ev) {
      _this2.cacheKeyFrame(ev.item);
    });
  };

  _proto.cacheKeyFrame = function cacheKeyFrame(item) {
    var keyFrameCache = this.keyFrameCache;
    var group = item.getGraphicGroup();

    if (item.isEdge) {
      group.setMatrix([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    }

    group.deepEach(function (element) {
      var id = element.gid;
      var stash = {
        matrix: Util.cloneDeep(element.getMatrix())
      };

      if (element.isItemContainer) {
        stash.enterAnimate = item.getEnterAnimate();
        stash.leaveAnimate = item.getLeaveAnimate();
      }

      if (element.isShape) {
        stash.attrs = Util.cloneDeep(element.attr());
      }

      stash.item = item;
      keyFrameCache[id] = stash;
    }, true);
  };

  _proto._compare = function _compare() {
    var stash0 = this.stash0;
    var stash1 = this.stash1;
    var enterElements = [];
    var leaveElements = [];
    var updateElements = [];
    Util.each(stash1, function (v, k) {
      if (stash0[k]) {
        if (v.element.get('type') === stash0[k].element.get('type')) {
          updateElements.push(k);
        }
      } else {
        enterElements.push(k);
      }
    });
    Util.each(stash0, function (v, k) {
      if (!stash1[k]) {
        leaveElements.push(k);
      }
    });
    this.enterElements = enterElements;
    this.leaveElements = leaveElements;
    this.updateElements = updateElements;
  };

  _proto._addTween = function _addTween() {
    var graph = this.graph;
    var updateAnimate = graph.get('_updateAnimate');
    var enterElements = this.enterElements;
    var leaveElements = this.leaveElements;
    var updateElements = this.updateElements;
    var stash0 = this.stash0;
    var stash1 = this.stash1;
    var keyFrameCache = this.keyFrameCache;
    enterElements.forEach(function (elementId) {
      var keyFrame = keyFrameCache[elementId];
      var enterAnimate = keyFrame.enterAnimate;

      if (enterAnimate) {
        enterAnimate(keyFrame.item, stash0.element, stash1.element);
      }
    });
    Util.each(leaveElements, function (elementId) {
      var keyFrame = keyFrameCache[elementId];
      var leaveAnimate = keyFrame.leaveAnimate;

      if (leaveAnimate) {
        var e0 = stash0[elementId].element;
        e0.getParent().add(e0);
        leaveAnimate(keyFrame.item, stash0, stash1);
      }
    });
    Util.each(updateElements, function (elementId) {
      var keyFrame = keyFrameCache[elementId];
      var subStash1 = stash1[elementId];
      var subStash0 = stash0[elementId];
      var e1 = subStash1.element;
      var e0 = subStash0.element;
      var visibleAction = 'none';

      if (subStash1.visible && !subStash0.visible) {
        visibleAction = 'show';
      } else if (!subStash1.visible && subStash0.visible) {
        visibleAction = 'hide';
      }

      if (subStash0.attrsStash) {
        e1.attr(subStash0.attrsStash);
      }

      e1.setMatrix(Util.cloneDeep(subStash0.matrixStash));
      updateAnimate(e1, Util.mix({}, keyFrame.attrs, {
        matrix: keyFrame.matrix
      }), visibleAction);

      if (e0 !== e1) {
        e0.remove();
      }
    });
  };

  _proto.getDefaultCfg = function getDefaultCfg() {
    return {
      graph: null,
      canvases: null,
      stash0: null,
      stash1: null,
      keyFrameCache: {}
    };
  };

  _proto.run = function run() {
    if (this.graph.destroyed) {
      return;
    }

    this.updateStash();

    if (this.count < 5000) {
      this._compare();

      this._addTween();
    }

    Util.each(this.canvases, function (canvas) {
      canvas.draw();
    });
  };

  _proto.updateStash = function updateStash() {
    var canvases = this.canvases;
    var elementsStash = this.elementsStash;
    var elements = {};
    var count = 0;
    elementsStash = elementsStash ? elementsStash : {};
    Util.each(canvases, function (canvas) {
      count += getElements(elements, canvas, 0);
    });
    this.elementsStash = elements;
    this.stash0 = elementsStash;
    this.stash1 = elements;
    this.count = count;
  };

  return Controller;
}(Base);

module.exports = Controller;