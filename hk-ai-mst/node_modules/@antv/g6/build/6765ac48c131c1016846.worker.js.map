{"version":3,"file":"6765ac48c131c1016846.worker.js","sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/./plugins/layout.forceAtlas2/body.js","webpack://[name]/./plugins/layout.forceAtlas2/forceCalculator.js","webpack://[name]/./plugins/layout.forceAtlas2/layout.worker.js","webpack://[name]/./plugins/layout.forceAtlas2/quad.js","webpack://[name]/./plugins/layout.forceAtlas2/quadTree.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./plugins/layout.forceAtlas2/layout.worker.js\");\n","/**\n * @fileOverview body\n * @author shiwu.wyy@antfin.com\n */\n// represents a body(a point mass) and its position\nvar Body =\n/*#__PURE__*/\nfunction () {\n  function Body(params) {\n    /**\n     * the id of this body, the same with the node id\n     * @type  {number}\n     */\n    this.id = params.id;\n    /**\n     * the position of this body\n     * @type  {number}\n     */\n\n    this.rx = params.rx;\n    /**\n     * the position of this body\n     * @type  {number}\n     */\n\n    this.ry = params.ry;\n    /**\n     * the force acting on this body\n     * @type  {number}\n     */\n\n    this.fx = 0;\n    /**\n     * the force acting on this body\n     * @type  {number}\n     */\n\n    this.fy = 0;\n    /**\n     * the mass of this body, =1 for a node\n     * @type  {number}\n     */\n\n    this.mass = params.mass;\n    /**\n     * the degree of the node represented by this body\n     * @type  {number}\n     */\n\n    this.degree = params.degree;\n    /**\n     * the parameter for repulsive force, = kr\n     * @type  {number}\n     */\n\n    this.G = params.G;\n  } // returns the euclidean distance\n\n\n  var _proto = Body.prototype;\n\n  _proto.distanceTo = function distanceTo(bo) {\n    var dx = this.rx - bo.rx;\n    var dy = this.ry - bo.ry;\n    return Math.hypot(dx, dy);\n  };\n\n  _proto.setPos = function setPos(x, y) {\n    this.rx = x;\n    this.ry = y;\n  }; // resets the forces\n\n\n  _proto.resetForce = function resetForce() {\n    this.fx = 0;\n    this.fy = 0;\n  };\n\n  _proto.addForce = function addForce(b) {\n    var dx = b.rx - this.rx;\n    var dy = b.ry - this.ry;\n    var dist = Math.hypot(dx, dy);\n    dist = dist < 0.0001 ? 0.0001 : dist; // the repulsive defined by force atlas 2\n\n    var F = this.G * (this.degree + 1) * (b.degree + 1) / dist;\n    this.fx += F * dx / dist;\n    this.fy += F * dy / dist;\n  }; // if quad contains this body\n\n\n  _proto.in = function _in(quad) {\n    return quad.contains(this.rx, this.ry);\n  }; // returns a new body\n\n\n  _proto.add = function add(bo) {\n    var nenwMass = this.mass + bo.mass;\n    var x = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;\n    var y = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;\n    var dg = this.degree + bo.degree;\n    var params = {\n      rx: x,\n      ry: y,\n      mass: nenwMass,\n      degree: dg\n    };\n    return new Body(params);\n  };\n\n  return Body;\n}();\n\nmodule.exports = Body;","var Body = require('./body');\n\nvar Quad = require('./quad');\n\nvar QuadTree = require('./quadTree');\n\nvar ForceCalculator =\n/*#__PURE__*/\nfunction () {\n  function ForceCalculator() {}\n\n  var _proto = ForceCalculator.prototype;\n\n  _proto.updateNodesByForces = function updateNodesByForces(data) {\n    var nodes = data.nodes,\n        edges = data.edges,\n        maxIteration = data.maxIteration,\n        barnesHut = data.barnesHut,\n        prune = data.prune;\n    edges = edges.filter(function (edge) {\n      return edge.source !== edge.target;\n    });\n    var size = nodes.length;\n    var esize = edges.length;\n    var degrees = [];\n    var idMap = {};\n    var edgeEndsIdMap = {};\n    var Es = [];\n\n    for (var i = 0; i < size; i += 1) {\n      idMap[nodes[i].id] = i;\n      degrees[i] = 0;\n\n      if (nodes[i].x === undefined || isNaN(nodes[i].x)) {\n        nodes[i].x = Math.random() * 1000;\n      }\n\n      if (nodes[i].y === undefined || isNaN(nodes[i].y)) {\n        nodes[i].y = Math.random() * 1000;\n      }\n\n      Es.push({\n        x: nodes[i].x,\n        y: nodes[i].y\n      });\n    }\n\n    for (var _i = 0; _i < esize; _i += 1) {\n      var node1 = void 0;\n      var node2 = void 0;\n      var sIdx = 0,\n          tIdx = 0;\n\n      for (var j = 0; j < size; j += 1) {\n        if (nodes[j].id === edges[_i].source) {\n          node1 = nodes[j];\n          sIdx = j;\n        } else if (nodes[j].id === edges[_i].target) {\n          node2 = nodes[j];\n          tIdx = j;\n        }\n\n        edgeEndsIdMap[_i] = {\n          sourceIdx: sIdx,\n          targetIdx: tIdx\n        };\n      }\n\n      degrees[idMap[node1.id]] += 1;\n      degrees[idMap[node2.id]] += 1;\n    }\n\n    var iteration = maxIteration;\n    var iterateParam = {\n      data: data,\n      size: size,\n      esize: esize,\n      idMap: idMap,\n      degrees: degrees,\n      iteration: iteration,\n      prune: prune,\n      barnesHut: barnesHut,\n      edgeEndsIdMap: edgeEndsIdMap\n    };\n    nodes = this.iterate(iterateParam); // if prune, place the leaves around their parents, and then re-layout for several iterations.\n\n    if (prune) {\n      for (var _j = 0; _j < esize; _j += 1) {\n        if (degrees[edgeEndsIdMap[_j].sourceIdx] <= 1) {\n          nodes[edgeEndsIdMap[_j].sourceIdx].x = nodes[edgeEndsIdMap[_j].targetIdx].x;\n          nodes[edgeEndsIdMap[_j].sourceIdx].y = nodes[edgeEndsIdMap[_j].targetIdx].y;\n        } else if (degrees[edgeEndsIdMap[_j].targetIdx] <= 1) {\n          nodes[edgeEndsIdMap[_j].targetIdx].x = nodes[edgeEndsIdMap[_j].sourceIdx].x;\n          nodes[edgeEndsIdMap[_j].targetIdx].y = nodes[edgeEndsIdMap[_j].sourceIdx].y;\n        }\n      }\n\n      prune = false;\n      barnesHut = false;\n      iteration = 100;\n      var iterateParamAfterPrune = {\n        data: data,\n        size: size,\n        esize: esize,\n        idMap: idMap,\n        degrees: degrees,\n        iteration: iteration,\n        prune: prune,\n        barnesHut: barnesHut,\n        edgeEndsIdMap: edgeEndsIdMap\n      };\n      nodes = this.iterate(iterateParamAfterPrune);\n    }\n\n    return nodes;\n  };\n\n  _proto.iterate = function iterate(params) {\n    var data = params.data,\n        size = params.size,\n        esize = params.esize,\n        idMap = params.idMap,\n        degrees = params.degrees,\n        iteration = params.iteration,\n        prune = params.prune,\n        barnesHut = params.barnesHut,\n        edgeEndsIdMap = params.edgeEndsIdMap;\n    var nodes = data.nodes,\n        ks = data.ks,\n        kr = data.kr,\n        kg = data.kg,\n        mode = data.mode,\n        prevOverlapping = data.prevOverlapping,\n        dissuadeHubs = data.dissuadeHubs,\n        ksmax = data.ksmax,\n        tao = data.tao,\n        center = data.center,\n        widths = data.widths;\n    var SG = 0;\n    var krPrime = 100;\n    var iter = iteration;\n    var prevoIter = 50;\n    var Forces = [];\n    var preForces = [];\n    var bodies = [];\n\n    for (var i = 0; i < size; i += 1) {\n      Forces[2 * i] = 0;\n      Forces[2 * i + 1] = 0;\n\n      if (barnesHut) {\n        var _params = {\n          id: i,\n          rx: nodes[i].x,\n          ry: nodes[i].y,\n          mass: 1,\n          G: kr,\n          degree: degrees[i]\n        };\n        bodies[i] = new Body(_params);\n        _params = null;\n      }\n    }\n\n    do {\n      for (var _i2 = 0; _i2 < size; _i2 += 1) {\n        preForces[2 * _i2] = Forces[2 * _i2];\n        preForces[2 * _i2 + 1] = Forces[2 * _i2 + 1];\n        Forces[2 * _i2] = 0;\n        Forces[2 * _i2 + 1] = 0;\n      } // attractive forces, existing on every actual edge\n\n\n      var attrForceParam = {\n        nodes: nodes,\n        esize: esize,\n        prevOverlapping: prevOverlapping,\n        dissuadeHubs: dissuadeHubs,\n        mode: mode,\n        iter: iter,\n        prevoIter: prevoIter,\n        Forces: Forces,\n        widths: widths,\n        idMap: idMap,\n        degrees: degrees,\n        prune: prune,\n        edgeEndsIdMap: edgeEndsIdMap\n      };\n      Forces = this.getAttrForces(attrForceParam); // repulsive forces and Gravity, existing on every node pair\n      // if prevOverlapping, using the no-optimized method in the last prevoIter instead.\n\n      if (barnesHut && (prevOverlapping && iter > prevoIter || !prevOverlapping)) {\n        var optRepGraForceParam = {\n          nodes: nodes,\n          size: size,\n          Forces: Forces,\n          kg: kg,\n          center: center,\n          bodies: bodies,\n          degrees: degrees,\n          prune: prune\n        };\n        Forces = this.getOptRepGraForces(optRepGraForceParam);\n      } else {\n        var repGraForceParam = {\n          nodes: nodes,\n          size: size,\n          prevOverlapping: prevOverlapping,\n          iter: iter,\n          prevoIter: prevoIter,\n          Forces: Forces,\n          kr: kr,\n          krPrime: krPrime,\n          kg: kg,\n          center: center,\n          widths: widths,\n          degrees: degrees,\n          prune: prune\n        };\n        Forces = this.getRepGraForces(repGraForceParam);\n      } //   // update the positions\n\n\n      var updatePosParam = {\n        size: size,\n        nodes: nodes,\n        Forces: Forces,\n        preForces: preForces,\n        SG: SG,\n        ks: ks,\n        ksmax: ksmax,\n        tao: tao,\n        degrees: degrees,\n        prune: prune\n      };\n      var res = this.updatePos(updatePosParam);\n      nodes = res[0];\n      SG = res[1];\n      iter -= 1;\n    } while (iter > 0);\n\n    return nodes;\n  };\n\n  _proto.getAttrForces = function getAttrForces(params) {\n    var nodes = params.nodes,\n        esize = params.esize,\n        prevOverlapping = params.prevOverlapping,\n        dissuadeHubs = params.dissuadeHubs,\n        mode = params.mode,\n        iter = params.iter,\n        prevoIter = params.prevoIter,\n        Forces = params.Forces,\n        widths = params.widths,\n        idMap = params.idMap,\n        degrees = params.degrees,\n        prune = params.prune,\n        edgeEndsIdMap = params.edgeEndsIdMap;\n\n    for (var i = 0; i < esize; i += 1) {\n      var sourceNode = nodes[edgeEndsIdMap[i].sourceIdx];\n      var sourceIdx = edgeEndsIdMap[i].sourceIdx;\n      var targetNode = nodes[edgeEndsIdMap[i].targetIdx];\n      var targetIdx = edgeEndsIdMap[i].targetIdx;\n      if (prune && (degrees[sourceIdx] <= 1 || degrees[targetIdx] <= 1)) continue;\n      var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];\n      var eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      if (prevOverlapping && iter < prevoIter) eucliDis = eucliDis - widths[sourceIdx] - widths[targetIdx];\n      var Fa1 = eucliDis;\n      var Fa2 = Fa1;\n\n      if (mode === 'linlog') {\n        Fa1 = Math.log(1 + eucliDis);\n        Fa2 = Fa1;\n      }\n\n      if (dissuadeHubs) {\n        Fa1 = eucliDis / degrees[sourceIdx];\n        Fa2 = eucliDis / degrees[targetIdx];\n      }\n\n      if (prevOverlapping && iter < prevoIter && eucliDis <= 0) {\n        Fa1 = 0;\n        Fa2 = 0;\n      } else if (prevOverlapping && iter < prevoIter && eucliDis > 0) {\n        Fa1 = eucliDis;\n        Fa2 = eucliDis;\n      }\n\n      Forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];\n      Forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];\n      Forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];\n      Forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];\n      dir = null;\n    }\n\n    return Forces;\n  };\n\n  _proto.getRepGraForces = function getRepGraForces(params) {\n    var nodes = params.nodes,\n        size = params.size,\n        prevOverlapping = params.prevOverlapping,\n        iter = params.iter,\n        prevoIter = params.prevoIter,\n        Forces = params.Forces,\n        kr = params.kr,\n        krPrime = params.krPrime,\n        kg = params.kg,\n        center = params.center,\n        widths = params.widths,\n        degrees = params.degrees,\n        prune = params.prune;\n\n    for (var i = 0; i < size; i += 1) {\n      for (var j = i + 1; j < size; j += 1) {\n        if (prune && (degrees[i] <= 1 || degrees[j] <= 1)) continue;\n        var _dir = [nodes[j].x - nodes[i].x, nodes[j].y - nodes[i].y];\n\n        var _eucliDis = Math.hypot(_dir[0], _dir[1]);\n\n        _eucliDis = _eucliDis < 0.0001 ? 0.0001 : _eucliDis;\n        _dir[0] = _dir[0] / _eucliDis;\n        _dir[1] = _dir[1] / _eucliDis;\n        if (prevOverlapping && iter < prevoIter) _eucliDis = _eucliDis - widths[i] - widths[j];\n        var Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis;\n\n        if (prevOverlapping && iter < prevoIter && _eucliDis < 0) {\n          Fr = krPrime * (degrees[i] + 1) * (degrees[j] + 1);\n        } else if (prevOverlapping && iter < prevoIter && _eucliDis === 0) {\n          Fr = 0;\n        } else if (prevOverlapping && iter < prevoIter && _eucliDis > 0) {\n          Fr = kr * (degrees[i] + 1) * (degrees[j] + 1) / _eucliDis;\n        }\n\n        Forces[2 * i] -= Fr * _dir[0];\n        Forces[2 * j] += Fr * _dir[0];\n        Forces[2 * i + 1] -= Fr * _dir[1];\n        Forces[2 * j + 1] += Fr * _dir[1];\n        _dir = null;\n      } // gravity\n\n\n      var dir = [nodes[i].x - center.x, nodes[i].y - center.y];\n      var eucliDis = Math.hypot(dir[0], dir[1]);\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      var Fg = kg * (degrees[i] + 1);\n      Forces[2 * i] -= Fg * dir[0];\n      Forces[2 * i + 1] -= Fg * dir[1];\n      dir = null;\n    }\n\n    return Forces;\n  };\n\n  _proto.getOptRepGraForces = function getOptRepGraForces(params) {\n    var nodes = params.nodes,\n        size = params.size,\n        Forces = params.Forces,\n        kg = params.kg,\n        center = params.center,\n        bodies = params.bodies,\n        degrees = params.degrees,\n        prune = params.prune;\n    var minx = 9e10,\n        maxx = -9e10,\n        miny = 9e10,\n        maxy = -9e10;\n\n    for (var i = 0; i < size; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      bodies[i].setPos(nodes[i].x, nodes[i].y);\n      if (nodes[i].x >= maxx) maxx = nodes[i].x;\n      if (nodes[i].x <= minx) minx = nodes[i].x;\n      if (nodes[i].y >= maxy) maxy = nodes[i].y;\n      if (nodes[i].y <= miny) miny = nodes[i].y;\n    }\n\n    var width = Math.max(maxx - minx, maxy - miny);\n    var quadParams = {\n      xmid: (maxx + minx) / 2,\n      ymid: (maxy + miny) / 2,\n      length: width,\n      massCenter: center,\n      mass: size\n    };\n    var quad = new Quad(quadParams);\n    var quadTree = new QuadTree(quad); // build the tree, insert the nodes(quads) into the tree\n\n    for (var _i3 = 0; _i3 < size; _i3 += 1) {\n      if (prune && degrees[_i3] <= 1) continue;\n      if (bodies[_i3].in(quad)) quadTree.insert(bodies[_i3]);\n    } // update the repulsive forces and the gravity.\n\n\n    for (var _i4 = 0; _i4 < size; _i4 += 1) {\n      if (prune && degrees[_i4] <= 1) continue;\n\n      bodies[_i4].resetForce();\n\n      quadTree.updateForce(bodies[_i4]);\n      Forces[2 * _i4] -= bodies[_i4].fx;\n      Forces[2 * _i4 + 1] -= bodies[_i4].fy; // gravity\n\n      var dir = [nodes[_i4].x - center.x, nodes[_i4].y - center.y];\n      var eucliDis = Math.hypot(dir[0], dir[1]);\n      eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;\n      dir[0] = dir[0] / eucliDis;\n      dir[1] = dir[1] / eucliDis;\n      var Fg = kg * (degrees[_i4] + 1);\n      Forces[2 * _i4] -= Fg * dir[0];\n      Forces[2 * _i4 + 1] -= Fg * dir[1];\n      eucliDis = null;\n      Fg = null;\n      dir = null;\n    }\n\n    quadParams = null;\n    quad = null;\n    quadTree = null;\n    width = null;\n    return Forces;\n  };\n\n  _proto.updatePos = function updatePos(params) {\n    var size = params.size,\n        nodes = params.nodes,\n        Forces = params.Forces,\n        preForces = params.preForces,\n        SG = params.SG,\n        ks = params.ks,\n        ksmax = params.ksmax,\n        tao = params.tao,\n        degrees = params.degrees,\n        prune = params.prune;\n    var swgns = [];\n    var trans = []; // swg(G) and tra(G)\n\n    var swgG = 0;\n    var traG = 0;\n\n    for (var i = 0; i < size; i += 1) {\n      if (prune && degrees[i] <= 1) continue;\n      var minus = [Forces[2 * i] - preForces[2 * i], Forces[2 * i + 1] - preForces[2 * i + 1]];\n      var minusNorm = Math.hypot(minus[0], minus[1]);\n      var add = [Forces[2 * i] + preForces[2 * i], Forces[2 * i + 1] + preForces[2 * i + 1]];\n      var addNorm = Math.hypot(add[0], add[1]);\n      swgns[i] = minusNorm;\n      trans[i] = addNorm / 2;\n      swgG += (degrees[i] + 1) * swgns[i];\n      traG += (degrees[i] + 1) * trans[i];\n    }\n\n    var preSG = SG;\n    SG = tao * traG / swgG;\n\n    if (preSG !== 0) {\n      SG = SG > 1.5 * preSG ? 1.5 * preSG : SG;\n    } // update the node positions\n\n\n    for (var _i5 = 0; _i5 < size; _i5 += 1) {\n      if (prune && degrees[_i5] <= 1) continue;\n      var Sn = ks * SG / (1 + SG * Math.sqrt(swgns[_i5]));\n      var absForce = Math.hypot(Forces[2 * _i5], Forces[2 * _i5 + 1]);\n      absForce = absForce < 0.0001 ? 0.0001 : absForce;\n      var max = ksmax / absForce;\n      Sn = Sn > max ? max : Sn;\n      var Dnx = Sn * Forces[2 * _i5];\n      var Dny = Sn * Forces[2 * _i5 + 1];\n      nodes[_i5].x += Dnx;\n      nodes[_i5].y += Dny;\n    }\n\n    swgns = null;\n    trans = null;\n    preSG = null;\n    return [nodes, SG];\n  };\n\n  return ForceCalculator;\n}();\n\nmodule.exports = ForceCalculator;","\nconst ForceCal = require('./forceCalculator');\nonmessage = function(event) {\n  const forceCal = new ForceCal();\n  const nodes = forceCal.updateNodesByForces(event.data);\n  self.postMessage(nodes);\n};\n","/**\n * @fileOverview quad\n * @author shiwu.wyy@antfin.com\n */\nvar Quad =\n/*#__PURE__*/\nfunction () {\n  function Quad(params) {\n    /**\n     * the center position of this quad\n     * @type  {number}\n     */\n    this.xmid = params.xmid;\n    /**\n     * the center position of this quad\n     * @type  {number}\n     */\n\n    this.ymid = params.ymid;\n    /**\n     * the length of this quad\n     * @type  {number}\n     */\n\n    this.length = params.length;\n    /**\n     * the mass center of this quad\n     * @type  {number}\n     */\n\n    this.massCenter = params.massCenter;\n    /**\n     * the mass of this quad\n     * @type  {number}\n     */\n\n    this.mass = params.mass;\n  }\n\n  var _proto = Quad.prototype;\n\n  _proto.getLength = function getLength() {\n    return this.length;\n  };\n\n  _proto.contains = function contains(x, y) {\n    var halfLen = this.length / 2;\n    return x <= this.xmid + halfLen && x >= this.xmid - halfLen && y <= this.ymid + halfLen && y >= this.ymid - halfLen;\n  }; // northwest quadrant\n\n\n  _proto.NW = function NW() {\n    var x = this.xmid - this.length / 4;\n    var y = this.ymid + this.length / 4;\n    var len = this.length / 2;\n    var params = {\n      xmid: x,\n      ymid: y,\n      length: len\n    };\n    var NW = new Quad(params);\n    return NW;\n  }; // northeast\n\n\n  _proto.NE = function NE() {\n    var x = this.xmid + this.length / 4;\n    var y = this.ymid + this.length / 4;\n    var len = this.length / 2;\n    var params = {\n      xmid: x,\n      ymid: y,\n      length: len\n    };\n    var NE = new Quad(params);\n    return NE;\n  }; // southwest\n\n\n  _proto.SW = function SW() {\n    var x = this.xmid - this.length / 4;\n    var y = this.ymid - this.length / 4;\n    var len = this.length / 2;\n    var params = {\n      xmid: x,\n      ymid: y,\n      length: len\n    };\n    var SW = new Quad(params);\n    return SW;\n  }; // southeast\n\n\n  _proto.SE = function SE() {\n    var x = this.xmid + this.length / 4;\n    var y = this.ymid - this.length / 4;\n    var len = this.length / 2;\n    var params = {\n      xmid: x,\n      ymid: y,\n      length: len\n    };\n    var SE = new Quad(params);\n    return SE;\n  };\n\n  return Quad;\n}();\n\nmodule.exports = Quad;","/**\n * @fileOverview quadTree\n * @author shiwu.wyy@antfin.com\n */\nvar QuadTree =\n/*#__PURE__*/\nfunction () {\n  // each quadtree represents a quadrant and an aggregate body\n  // that represents all bodies inside the quadrant\n  function QuadTree(param) {\n    /**\n     * (aggregated) body in this quad\n     * @type  {object}\n     */\n    this.body = null;\n    /**\n     * tree representing the northwest quadrant\n     * @type  {object}\n     */\n\n    this.quad = null;\n    this.NW = null;\n    this.NE = null;\n    this.SW = null;\n    this.SE = null;\n    /**\n     * threshold\n     * @type  {number}\n     */\n\n    this.theta = 0.5;\n    if (param != null) this.quad = param;\n  } // insert a body(node) into the tree\n\n\n  var _proto = QuadTree.prototype;\n\n  _proto.insert = function insert(bo) {\n    // if this node does not contain a body, put the new body bo here\n    if (this.body == null) {\n      this.body = bo;\n      return;\n    } // internal node\n\n\n    if (!this._isExternal()) {\n      // update mass info\n      this.body = this.body.add(bo); // insert body into quadrant\n\n      this._putBody(bo);\n    } else {\n      // external node\n      // divide this region into four children\n      this.NW = new QuadTree(this.quad.NW());\n      this.NE = new QuadTree(this.quad.NE());\n      this.SW = new QuadTree(this.quad.SW());\n      this.SE = new QuadTree(this.quad.SE()); // insert this body and bo\n\n      this._putBody(this.body);\n\n      this._putBody(bo); // update the mass info\n\n\n      this.body = this.body.add(bo);\n    }\n  }; // inserts bo into a quad\n\n\n  _proto._putBody = function _putBody(bo) {\n    if (bo.in(this.quad.NW())) this.NW.insert(bo);else if (bo.in(this.quad.NE())) this.NE.insert(bo);else if (bo.in(this.quad.SW())) this.SW.insert(bo);else if (bo.in(this.quad.SE())) this.SE.insert(bo);\n  };\n\n  _proto._isExternal = function _isExternal() {\n    // four children are null\n    return this.NW == null && this.NE == null && this.SW == null && this.SE == null;\n  }; // update the forces\n\n\n  _proto.updateForce = function updateForce(bo) {\n    if (this.body == null || bo === this.body) {\n      return;\n    } // if the current node is external\n\n\n    if (this._isExternal()) bo.addForce(this.body); // internal nodes\n    else {\n        var s = this.quad.getLength();\n        var d = this.body.distanceTo(bo); // b is far enough\n\n        if (s / d < this.theta) bo.addForce(this.body);else {\n          this.NW.updateForce(bo);\n          this.NE.updateForce(bo);\n          this.SW.updateForce(bo);\n          this.SE.updateForce(bo);\n        }\n      }\n  };\n\n  return QuadTree;\n}();\n\nmodule.exports = QuadTree;"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}